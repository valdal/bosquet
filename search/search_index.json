{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"bosquet","text":"<p>Python library for symbolic manipulation of Butcher trees and B-series</p>"},{"location":"modules/","title":"Modules","text":""},{"location":"modules/#bosquet.trees.TreeIndex","title":"<code>TreeIndex = tuple[int, int]</code>  <code>module-attribute</code>","text":"<p>Type for tree index represented as a tuple of two integers: (uncolored tree index, color index).</p>"},{"location":"modules/#bosquet.trees.Tree","title":"<code>Tree</code>","text":"<p>A class representing a rooted tree and its operations.</p> <p>A tree is represented by its index in the sequence of all trees.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>@total_ordering\nclass Tree:\n    \"\"\"A class representing a rooted tree and its operations.\n\n    A tree is represented by its index in the sequence of all trees.\n    \"\"\"\n\n    _num_colors: ClassVar[int] = 1\n    _is_linear: ClassVar[list[bool]] = [False]\n\n    _order_max: ClassVar[int] = 0\n    _comp: ClassVar[list[tuple[int, int]]] = [(0, 0)]\n    _comp_colors: ClassVar[list[list[tuple[int, int]]]] = [[(0, 0)]]\n    _index_first: ClassVar[list] = [0, 1]\n\n    @classmethod\n    def clear(cls) -&gt; None:\n        \"\"\"Clears all generated trees and caches values for this class.\"\"\"\n\n        cls._order_max = 0\n        cls._comp = [(0, 0)]\n        cls._comp_colors = [[(0, 0)]]\n        cls._index_first = [0, 1]\n\n        # Clear all cached values\n        for attr_name in dir(cls):\n            if attr_name.endswith(\"_cache\") and attr_name.startswith(\"_\"):\n                delattr(cls, attr_name)\n\n    @classmethod\n    def set_num_colors(cls, n: int, is_linear: list[bool] | None = None) -&gt; None:\n        \"\"\"Set the number of color for the trees\n\n        Args:\n            n (int): Number of colors\n        \"\"\"\n        if n &lt; 1:\n            raise ValueError(\"Number of colors must be at least 1\")\n        if is_linear is None:\n            is_linear = [False] * n\n        if len(is_linear) != n:\n            raise ValueError(f\"len(is_linear) must be {n}, got {len(is_linear)}\")\n\n        cls._num_colors = n\n        cls._is_linear = is_linear\n\n        cls.clear()\n\n    @classmethod\n    def num_colors(cls) -&gt; int:\n        return cls._num_colors\n\n    @classmethod\n    def is_linear(cls, root: int) -&gt; bool:\n        if root &lt; 0 or root &gt;= cls._num_colors:\n            raise ValueError(f\"Root must be in range [0, {cls._num_colors - 1}], got {root}\")\n        return cls._is_linear[root]\n\n    def __init__(self, index: int, coloring: int = 0) -&gt; None:\n        \"\"\"Initialize a Tree with the given index\n\n        Args:\n            index int: The index of the uncolored tree.\n            coloring (int, optional): The index of the coloring of the tree. Defaults to 0.\n        \"\"\"\n        if index &lt; 0:\n            raise ValueError(\"Tree index must be non-negative\")\n        if coloring &lt; 0:\n            raise ValueError(\"Color index must be non-negative\")\n\n        # Generate trees until we have the index\n        self.generate_index(index)\n\n        if coloring &gt;= len(self._comp_colors[index]):\n            raise ValueError(f\"Color index must be less than {len(self._comp_colors[index])}, got {coloring}\")\n\n        self.index = (index, coloring)\n\n    def __eq__(self, other: object) -&gt; bool:\n        \"\"\"Return True if the trees have the same index.\"\"\"\n        # Ensure both are from same dynamic class (same number of colors)\n        if not isinstance(other, type(self)):\n            return NotImplemented\n\n        return self.index == other.index\n\n    def __hash__(self) -&gt; int:\n        \"\"\"Return the hash of the tree's index.\"\"\"\n        return hash((type(self), self.index))\n\n    def __lt__(self, other: object) -&gt; bool:\n        \"\"\"Return True if the first trees have smaller index than other.\"\"\"\n        if not isinstance(other, type(self)):\n            return NotImplemented\n        return self.index &lt; other.index\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Return a string representation of the tree.\"\"\"\n        if self.num_colors() == 1:\n            return f\"Tree({self.index[0]})\"\n        else:\n            return f\"Tree({self.index[0]}, {self.index[1]})\"\n\n    @classmethod\n    def generate_trees(cls, new_order: int) -&gt; None:\n        \"\"\"Generate all trees up to the specified order.\n\n        Args:\n            new_order (int): The maximum order of trees to generate\n\n        Examples:\n            &gt;&gt;&gt; Tree.generate_trees(5)\n        \"\"\"\n        if new_order &lt; 0:\n            raise ValueError(\"Order must be non-negative\")\n\n        for order in range(cls._order_max + 1, new_order + 1):\n            for j in range(1, ceil(order / 2)):\n                idxLeft = cls.indices(order - j)\n                idxRight = cls.indices(j)\n                for left, right in product(idxLeft, idxRight):\n                    if not cls.is_linear(Tree(left).root) and Tree(left).right &gt;= Tree(right):\n                        cls._comp.append((left, right))\n                        cls._comp_colors.append([])\n                        for lc, rc in product(cls.colorings(left), cls.colorings(right)):\n                            cls._comp_colors[-1].append((lc, rc))\n\n            for r in cls.indices(order - 1):\n                cls._comp.append((1, r))\n                cls._comp_colors.append([])\n                for rc in cls.colorings(r):\n                    for root in range(cls._num_colors):\n                        cls._comp_colors[-1].append((root, rc))\n\n            cls._index_first.append(len(cls._comp))\n            cls._order_max = order\n\n    @classmethod\n    def generate_index(cls, index: int) -&gt; None:\n        if index &lt; 0:\n            raise ValueError(\"Index must be non-negative\")\n\n        order = cls._order_max + 1\n        while index &gt;= len(cls._comp):\n            cls.generate_trees(order)\n            order += 1\n\n    @classmethod\n    def indices(cls, order: int) -&gt; range:\n        \"\"\"Return the indices for all trees of specified order.\n\n        Args:\n            order: The order of trees to get indices for\n\n        Returns:\n            A range of indices for trees of the specified order\n\n        Examples:\n            &gt;&gt;&gt; [Tree(i) for i in Tree.indices(4)]\n            [Tree(5), Tree(6), Tree(7), Tree(8)]\n        \"\"\"\n        cls.generate_trees(order)\n        return range(cls._index_first[order], cls._index_first[order + 1])\n\n    @classmethod\n    def colorings(cls, index: int) -&gt; range:\n        cls.generate_index(index)\n        return range(len(cls._comp_colors[index]))\n\n    @property\n    def left(self) -&gt; \"Tree\":\n        \"\"\"Return the left tree in the circ product.\n\n        Returns:\n            A Tree instance representing the left tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; t.left.index\n            1\n        \"\"\"\n        idx = self._comp[self.index[0]][0]\n        col = self._comp_colors[self.index[0]][self.index[1]][0]\n        return Tree(idx, col)\n\n    @property\n    def right(self) -&gt; \"Tree\":\n        \"\"\"Return the right tree in the circ product.\n\n        Returns:\n            A Tree instance representing the right tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; t.right.index\n            2\n        \"\"\"\n        idx = self._comp[self.index[0]][1]\n        col = self._comp_colors[self.index[0]][self.index[1]][1]\n        return Tree(idx, col)\n\n    @property\n    def decompose(self) -&gt; tuple[\"Tree\", \"Tree\"]:\n        \"\"\"Return a tuple containing the left and right trees.\n\n        Returns:\n            A tuple (left_tree, right_tree)\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; left, right = t.decompose()\n            &gt;&gt;&gt; l.index, r.index\n            (1, 2)\n        \"\"\"\n        idx = self._comp[self.index[0]]\n        col = self._comp_colors[self.index[0]][self.index[1]]\n        return Tree(idx[0], col[0]), Tree(idx[1], col[1])\n\n    @classmethod\n    @fun_cache\n    def circ(cls, left: \"Tree\", right: \"Tree\") -&gt; \"Tree\":\n        sum_order = left.order + right.order\n        cls.generate_trees(sum_order)\n        try:\n            # Get the index (without coloring)\n            idx = cls._comp.index(\n                (left.index[0], right.index[0]), cls._index_first[sum_order], cls._index_first[sum_order + 1]\n            )\n            # Find the color index\n            col = cls._comp_colors[idx].index((left.index[1], right.index[1]))\n            return Tree(idx, col)\n        except ValueError:\n            return cls.from_children(left.children + Counter([right]), left.root, check_order=False)\n\n    @classmethod\n    def from_children(cls, children: Counter[\"Tree\"] | list[\"Tree\"], root: int = 0, check_order: bool = True) -&gt; \"Tree\":\n        if not isinstance(children, Counter):\n            children = Counter(children)\n\n        sorted_children = sorted(children.elements(), reverse=True)\n\n        if check_order:\n            order = sum(t.order * k for t, k in children.items())\n            cls.generate_trees(order)\n        return reduce(cls.circ, sorted_children, Tree(1, root))\n\n    @classmethod\n    def merge_root(cls, left: \"Tree\", right: \"Tree\", root: int = 0) -&gt; \"Tree\":\n        return cls.from_children(left.children + right.children, root)\n\n    @property\n    @cache(key_part=\"both\")\n    def root(self) -&gt; int:\n        \"\"\"Return the root of the tree\"\"\"\n        if self.index[0] == 0:\n            return -1\n        if self.index[0] == 1:\n            return self.index[1]\n        return self.left.root\n\n    @property\n    @cache(key_part=\"index\")\n    def order(self) -&gt; int:\n        \"\"\" \"\"\"\n        if self.index[0] == 0:\n            return 0\n        if self.index[0] == 1:\n            return 1\n        left, right = self.decompose\n        return left.order + right.order\n\n    @property\n    @cache(key_part=\"index\")\n    def gamma(self) -&gt; int:\n        \"\"\"Return the density of the tree.\n\n        Returns:\n            The density of the tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(5)\n            &gt;&gt;&gt; t.gamma\n            4\n        \"\"\"\n        if self.index[0] &lt;= 1:\n            return 1\n        g = self.order\n        for tree, count in self.children.items():\n            g *= tree.gamma**count\n\n        return g\n\n    @property\n    @cache(key_part=\"index\")\n    def sigma(self) -&gt; int:\n        \"\"\"Return the symmetry of the tree.\n\n        Returns:\n            The symmetry of the tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(5)\n            &gt;&gt;&gt; t.sigma\n            6\n        \"\"\"\n        s = 1\n        for c in self.children.items():\n            s *= factorial(c[1]) * c[0].sigma ** c[1]\n        return s\n\n    @property\n    def height(self) -&gt; int:\n        \"\"\"Return the height of the tree.\n\n        The height is defined as:\n        - height(t_0) = height(t_1) = 0\n        - height(t) = max(height(t') for t' in children) + 1\n\n        Returns:\n            The height of the tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; t.height\n            2\n        \"\"\"\n        if self.index[0] &lt;= 1:\n            return 0\n        return max(c.height for c, _ in self.children.items()) + 1\n\n    @property\n    def width(self) -&gt; int:\n        \"\"\"Return the width of the tree.\n\n        The width is defined as:\n        - width(t_0) = 0\n        - width(t_1) = 1\n        - width(t) = sum(k * width(t') for t',k in children.items())\n\n        Returns:\n            The width of the tree\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; t.width\n            1\n        \"\"\"\n        if self.index[0] &lt;= 1:\n            return self.index[0]\n        return sum(k * c.width for c, k in self.children.items())\n\n    @property\n    @cache(key_part=\"both\")\n    def children(self) -&gt; Counter[\"Tree\"]:\n        \"\"\"Return the trees obtained after removing the root.\n\n        The children are returned as a Counter mapping each subtree\n        to its multiplicity (how many times it appears).\n\n        Returns:\n            A Counter mapping Tree instances to their multiplicities\n\n        Examples:\n            &gt;&gt;&gt; t = Tree(4)\n            &gt;&gt;&gt; t.children  # Tree 4 has two copies of Tree 1 and one of Tree 2\n            Counter({Tree(2): 1})\n\n            &gt;&gt;&gt; t = Tree(10)\n            &gt;&gt;&gt; for child, mult in t.children.items():\n            ...     print(f\"Tree {child.index} appears {mult} times\")\n            Tree 2 appears 1 times\n            Tree 1 appears 2 times\n\n            &gt;&gt;&gt; # Sum multiplicities of all children\n            &gt;&gt;&gt; sum(t.children.values())\n            3\n        \"\"\"\n        if self.index[0] &lt;= 1:\n            return Counter()\n\n        left, right = self.decompose\n        return left.children + Counter([right])\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.children","title":"<code>children</code>  <code>property</code>","text":"<p>Return the trees obtained after removing the root.</p> <p>The children are returned as a Counter mapping each subtree to its multiplicity (how many times it appears).</p> <p>Returns:</p> Type Description <code>Counter[Tree]</code> <p>A Counter mapping Tree instances to their multiplicities</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; t.children  # Tree 4 has two copies of Tree 1 and one of Tree 2\nCounter({Tree(2): 1})\n</code></pre> <pre><code>&gt;&gt;&gt; t = Tree(10)\n&gt;&gt;&gt; for child, mult in t.children.items():\n...     print(f\"Tree {child.index} appears {mult} times\")\nTree 2 appears 1 times\nTree 1 appears 2 times\n</code></pre> <pre><code>&gt;&gt;&gt; # Sum multiplicities of all children\n&gt;&gt;&gt; sum(t.children.values())\n3\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.decompose","title":"<code>decompose</code>  <code>property</code>","text":"<p>Return a tuple containing the left and right trees.</p> <p>Returns:</p> Type Description <code>tuple[Tree, Tree]</code> <p>A tuple (left_tree, right_tree)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; left, right = t.decompose()\n&gt;&gt;&gt; l.index, r.index\n(1, 2)\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.gamma","title":"<code>gamma</code>  <code>property</code>","text":"<p>Return the density of the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The density of the tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(5)\n&gt;&gt;&gt; t.gamma\n4\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.height","title":"<code>height</code>  <code>property</code>","text":"<p>Return the height of the tree.</p> <p>The height is defined as: - height(t_0) = height(t_1) = 0 - height(t) = max(height(t') for t' in children) + 1</p> <p>Returns:</p> Type Description <code>int</code> <p>The height of the tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; t.height\n2\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.left","title":"<code>left</code>  <code>property</code>","text":"<p>Return the left tree in the circ product.</p> <p>Returns:</p> Type Description <code>Tree</code> <p>A Tree instance representing the left tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; t.left.index\n1\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.order","title":"<code>order</code>  <code>property</code>","text":""},{"location":"modules/#bosquet.trees.Tree.right","title":"<code>right</code>  <code>property</code>","text":"<p>Return the right tree in the circ product.</p> <p>Returns:</p> Type Description <code>Tree</code> <p>A Tree instance representing the right tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; t.right.index\n2\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.root","title":"<code>root</code>  <code>property</code>","text":"<p>Return the root of the tree</p>"},{"location":"modules/#bosquet.trees.Tree.sigma","title":"<code>sigma</code>  <code>property</code>","text":"<p>Return the symmetry of the tree.</p> <p>Returns:</p> Type Description <code>int</code> <p>The symmetry of the tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(5)\n&gt;&gt;&gt; t.sigma\n6\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.width","title":"<code>width</code>  <code>property</code>","text":"<p>Return the width of the tree.</p> <p>The width is defined as: - width(t_0) = 0 - width(t_1) = 1 - width(t) = sum(k * width(t') for t',k in children.items())</p> <p>Returns:</p> Type Description <code>int</code> <p>The width of the tree</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t = Tree(4)\n&gt;&gt;&gt; t.width\n1\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Return True if the trees have the same index.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>def __eq__(self, other: object) -&gt; bool:\n    \"\"\"Return True if the trees have the same index.\"\"\"\n    # Ensure both are from same dynamic class (same number of colors)\n    if not isinstance(other, type(self)):\n        return NotImplemented\n\n    return self.index == other.index\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.__hash__","title":"<code>__hash__()</code>","text":"<p>Return the hash of the tree's index.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return the hash of the tree's index.\"\"\"\n    return hash((type(self), self.index))\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.__init__","title":"<code>__init__(index, coloring=0)</code>","text":"<p>Initialize a Tree with the given index</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the uncolored tree.</p> required <code>coloring</code> <code>int</code> <p>The index of the coloring of the tree. Defaults to 0.</p> <code>0</code> Source code in <code>src/bosquet/trees.py</code> <pre><code>def __init__(self, index: int, coloring: int = 0) -&gt; None:\n    \"\"\"Initialize a Tree with the given index\n\n    Args:\n        index int: The index of the uncolored tree.\n        coloring (int, optional): The index of the coloring of the tree. Defaults to 0.\n    \"\"\"\n    if index &lt; 0:\n        raise ValueError(\"Tree index must be non-negative\")\n    if coloring &lt; 0:\n        raise ValueError(\"Color index must be non-negative\")\n\n    # Generate trees until we have the index\n    self.generate_index(index)\n\n    if coloring &gt;= len(self._comp_colors[index]):\n        raise ValueError(f\"Color index must be less than {len(self._comp_colors[index])}, got {coloring}\")\n\n    self.index = (index, coloring)\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.__lt__","title":"<code>__lt__(other)</code>","text":"<p>Return True if the first trees have smaller index than other.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>def __lt__(self, other: object) -&gt; bool:\n    \"\"\"Return True if the first trees have smaller index than other.\"\"\"\n    if not isinstance(other, type(self)):\n        return NotImplemented\n    return self.index &lt; other.index\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.__repr__","title":"<code>__repr__()</code>","text":"<p>Return a string representation of the tree.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Return a string representation of the tree.\"\"\"\n    if self.num_colors() == 1:\n        return f\"Tree({self.index[0]})\"\n    else:\n        return f\"Tree({self.index[0]}, {self.index[1]})\"\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.clear","title":"<code>clear()</code>  <code>classmethod</code>","text":"<p>Clears all generated trees and caches values for this class.</p> Source code in <code>src/bosquet/trees.py</code> <pre><code>@classmethod\ndef clear(cls) -&gt; None:\n    \"\"\"Clears all generated trees and caches values for this class.\"\"\"\n\n    cls._order_max = 0\n    cls._comp = [(0, 0)]\n    cls._comp_colors = [[(0, 0)]]\n    cls._index_first = [0, 1]\n\n    # Clear all cached values\n    for attr_name in dir(cls):\n        if attr_name.endswith(\"_cache\") and attr_name.startswith(\"_\"):\n            delattr(cls, attr_name)\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.generate_trees","title":"<code>generate_trees(new_order)</code>  <code>classmethod</code>","text":"<p>Generate all trees up to the specified order.</p> <p>Parameters:</p> Name Type Description Default <code>new_order</code> <code>int</code> <p>The maximum order of trees to generate</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; Tree.generate_trees(5)\n</code></pre> Source code in <code>src/bosquet/trees.py</code> <pre><code>@classmethod\ndef generate_trees(cls, new_order: int) -&gt; None:\n    \"\"\"Generate all trees up to the specified order.\n\n    Args:\n        new_order (int): The maximum order of trees to generate\n\n    Examples:\n        &gt;&gt;&gt; Tree.generate_trees(5)\n    \"\"\"\n    if new_order &lt; 0:\n        raise ValueError(\"Order must be non-negative\")\n\n    for order in range(cls._order_max + 1, new_order + 1):\n        for j in range(1, ceil(order / 2)):\n            idxLeft = cls.indices(order - j)\n            idxRight = cls.indices(j)\n            for left, right in product(idxLeft, idxRight):\n                if not cls.is_linear(Tree(left).root) and Tree(left).right &gt;= Tree(right):\n                    cls._comp.append((left, right))\n                    cls._comp_colors.append([])\n                    for lc, rc in product(cls.colorings(left), cls.colorings(right)):\n                        cls._comp_colors[-1].append((lc, rc))\n\n        for r in cls.indices(order - 1):\n            cls._comp.append((1, r))\n            cls._comp_colors.append([])\n            for rc in cls.colorings(r):\n                for root in range(cls._num_colors):\n                    cls._comp_colors[-1].append((root, rc))\n\n        cls._index_first.append(len(cls._comp))\n        cls._order_max = order\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.indices","title":"<code>indices(order)</code>  <code>classmethod</code>","text":"<p>Return the indices for all trees of specified order.</p> <p>Parameters:</p> Name Type Description Default <code>order</code> <code>int</code> <p>The order of trees to get indices for</p> required <p>Returns:</p> Type Description <code>range</code> <p>A range of indices for trees of the specified order</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; [Tree(i) for i in Tree.indices(4)]\n[Tree(5), Tree(6), Tree(7), Tree(8)]\n</code></pre> Source code in <code>src/bosquet/trees.py</code> <pre><code>@classmethod\ndef indices(cls, order: int) -&gt; range:\n    \"\"\"Return the indices for all trees of specified order.\n\n    Args:\n        order: The order of trees to get indices for\n\n    Returns:\n        A range of indices for trees of the specified order\n\n    Examples:\n        &gt;&gt;&gt; [Tree(i) for i in Tree.indices(4)]\n        [Tree(5), Tree(6), Tree(7), Tree(8)]\n    \"\"\"\n    cls.generate_trees(order)\n    return range(cls._index_first[order], cls._index_first[order + 1])\n</code></pre>"},{"location":"modules/#bosquet.trees.Tree.set_num_colors","title":"<code>set_num_colors(n, is_linear=None)</code>  <code>classmethod</code>","text":"<p>Set the number of color for the trees</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of colors</p> required Source code in <code>src/bosquet/trees.py</code> <pre><code>@classmethod\ndef set_num_colors(cls, n: int, is_linear: list[bool] | None = None) -&gt; None:\n    \"\"\"Set the number of color for the trees\n\n    Args:\n        n (int): Number of colors\n    \"\"\"\n    if n &lt; 1:\n        raise ValueError(\"Number of colors must be at least 1\")\n    if is_linear is None:\n        is_linear = [False] * n\n    if len(is_linear) != n:\n        raise ValueError(f\"len(is_linear) must be {n}, got {len(is_linear)}\")\n\n    cls._num_colors = n\n    cls._is_linear = is_linear\n\n    cls.clear()\n</code></pre>"}]}